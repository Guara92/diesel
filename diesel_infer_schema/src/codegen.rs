use std::error::Error;

use quote;
use syn;

use table_data::TableData;
use data_structures::ColumnInformation;
use inference::{establish_connection, get_table_data, determine_column_type, get_primary_keys,
                InferConnection};

macro_rules! doc_comment {
    ($($token:tt)*) => (
        format!($($token)*)
            .lines()
            .map(str::trim)
            .map(|l| syn::Token::DocComment(format!("/// {}", l)))
            .collect::<Vec<syn::Token>>()
    )
}

pub fn expand_infer_table_from_schema(database_url: &str, table: &TableData)
    -> Result<quote::Tokens, Box<Error>>
{
    let connection = establish_connection(database_url)?;
    let data = get_table_data(&connection, table)?;
    let primary_keys = get_primary_keys(&connection, table)?
        .into_iter()
        .map(syn::Ident::new);
    let table_name = syn::Ident::new(&*table.name);

    let mut tokens = Vec::with_capacity(data.len());

    for a in data {
        tokens.push(column_def_tokens(table, &a, &connection)?);
    }
    let default_schema = default_schema(&connection);

    let docs = doc_comment!(
        "Representation of the `{}` table.

        (Generated by Diesel's `infer_schema!` macro.)",
        table_name);

    let table_path = match table.schema {
        Some(ref schema) if table.schema != default_schema => {
            let schema_name = syn::Ident::new(&schema[..]);
            quote! { #schema_name.#table_name }
        },
        _ => quote! { #table_name },
    };

    Ok(quote!(table! {
        #(#docs)*
        #table_path (#(#primary_keys),*) {
            #(#tokens),*,
        }
    }))
}

pub fn handle_schema<I>(tables: I, schema_name: Option<&str>) -> quote::Tokens
    where I: Iterator<Item = quote::Tokens>
{
    match schema_name {
        Some(name) => {
            let schema_ident = syn::Ident::new(name);
            quote! { pub mod #schema_ident { #(#tables)* } }
        }
        None => quote!(#(#tables)*),
    }
}

fn column_def_tokens(
    table: &TableData,
    column: &ColumnInformation,
    connection: &InferConnection,
) -> Result<quote::Tokens, Box<Error>> {
    let column_name = syn::Ident::new(&*column.column_name);
    let column_type = match determine_column_type(column, connection) {
        Ok(t) => t,
        Err(e) => return Err(format!(
            "Error determining type of {}.{}: {}",
            table,
            column.column_name,
            e,
        ).into()),
    };

    let tpe = if column_type.path[0] == "diesel" && column_type.path[1] == "types" {
        let path_segments = column_type.path
            .into_iter()
            .skip(2)
            .map(syn::PathSegment::from)
            .collect();
        syn::Path { global: false, segments: path_segments }
    } else {
        let path_segments = column_type.path
            .into_iter()
            .map(syn::PathSegment::from)
            .collect();
        syn::Path { global: true, segments: path_segments }
    };
    let mut tpe = quote!(#tpe);

    if column_type.is_array {
        tpe = quote!(Array<#tpe>);
    }
    if column_type.is_nullable {
        tpe = quote!(Nullable<#tpe>);
    }

    let docs = doc_comment!("The `{}` column of the `{}` table.

        Its SQL type is `{}`.

        (Generated by Diesel's `infer_schema!` macro.)",
        column_name, table.name, tpe);

    Ok(quote! {
        #(#docs)*
        #column_name -> #tpe
    })
}

fn default_schema(conn: &InferConnection) -> Option<String> {
    #[cfg(feature="mysql")]
    use information_schema::UsesInformationSchema;
    #[cfg(feature="mysql")]
    use diesel::mysql::Mysql;

    match *conn {
        #[cfg(feature="sqlite")]
        InferConnection::Sqlite(_) => None,
        #[cfg(feature="postgres")]
        InferConnection::Pg(_) => Some("public".into()),
        #[cfg(feature="mysql")]
        InferConnection::Mysql(ref c) => Mysql::default_schema(c).ok(),
    }
}
